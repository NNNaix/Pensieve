# 编译器结构

## 历史

## FORTRAN 1 结构

1. **词法分析**：分析语法
2. **语法分析/解析**：解析语法
3. **语义分析**：语义方面，如类型和作用域规则
4. **优化**：对程序集合进行转换的集合，让程序运行的更快或占用更少的内存
5. **代码生成**：将输入语言转换成输出语言，根据我们的目标，可以是机器码，也可以是虚拟机上的字节码，亦或者是另一种高级编程语言。

## 编译器是如何理解程序的？

### 第一步：词法分析——理解单词

例如人类看到下面的语句：

```html
This is a sentence.
```

可以自然的理解到有 4 个单词

- `This`
- `is`
- `a`
- `sentence`

那么这样的语句呢：

```html
ist his ase nte nce /** Is this a sentence? **/
```

你不得不花时间去看看问题所在，因为这个句子并不是你平常看见的那样。
机器也是一样，机器理解的关键在于识别符号的含义

- 大写字母标志着语句的起点
- 空格标志着单词的起点/终点
- 句号标志着语句的终点
- ...

**词法分析的目标** 就是将程序代码文本按照它的方式进行分离为 单词 `words` 或 词法单元 `tokens`。

以下面的程序举例

```
if x == y then z = 1; else z = 2;
```

可以得到词法单元如下：

- 关键字：`if`，`then`，`else`
- 变量名：`x`，`y`，`z`
- 常量：`1`，`2`
- 运算符：`==`，`=`
- 分隔符：`;`，`space`

### 第二步：语法分析——理解句子结构

人类一旦理解了单词，那么下一步就是理解句子结构，也叫做 **语法分析** 。

语法分析等于图解句子。这些图都是树。

语法分析的第一步是去确认每个单词在这个句子中担任的角色，比如下面的句子

```
This      line    is     a        longer     sentence
 |         |      |      |          |           |
article   noun   verb  article  adjective     noun
```

语法分析之后的工作就是将这些单词组合在一起，变成更高级的结构。

```
This      line    is     a        longer     sentence
 |         |      |      |          |           |
article   noun   verb  article  adjective     noun
[--------------]      [-----------------------------]
      |                               |
    Subject                         Object
    [-------------------------------------]
                    |
                Sentence
```

对英文进行语法分析和对程序代码进行语法分析的过程是非常相似的。（实际上，它们就是一回事:P）

现在再回来看这段代码：

```
if x == y then z = 1;  else z = 2;
   |    |      |   |        |   |
  lo   ro     lo   ro      lo   ro
[--------]  [--------]   [--------]
    |           |            |
relation      assign       assign
[------]      [----]       [----]
    |           |            |
Predicate   then stat    else stat
[---------------------------------]
                |
           if-then-else
```

### 第三步： 语义分析——理解句子的表达意思

目前来说，我们无法完全的解释人类是如何理解这些句子的，所以对机器来说非常难（几乎不可能）做到和人类一样的理解能力。所以我们让编译器去做非常有限的语义分析。

比如下图，这个 `his` 可能表示 `jerry` 也可能表示 `jack`，在没有更多信息的情况下我们是无法判断的，而第二个例子中则最多可能出现三个不同的人（重名的`jack` 以及 第三人代称 `his`），在语义分析中，歧义是一个真实存在的问题。

![difficult-semantic-analysis](/resources/compiler-theory-difficult-semantic-analysis.png)

类似的，在编程中就是变量绑定的问题，实际的编程语言会定义严格的规则来避免这种歧义。
在这个例子中，我们有多个变量叫做 jack。

```c
{
    int jack = 3;
    {
        int jack = 4;
        cout << jack
    }
}
```

上面最终输出的 `jack` 是 `4`，因为有作用域的限制。

现在编译器在除了变量绑定外还执行了许多语义检查，例如通过类型检查来区分歧义。

### 第四步： 优化

优化的目标是在不影响语义的情况下，达成主要的两个目标：

1. 让最终的输出程序运行的更快
2. 让最终的输出程序占用更少的内存

再根据平台而言，我们可能关注

- 减少耗能
- 减少网络信息传递的次数/访问数据库的次数

来让我们看一个"示例"：

```javascript
// before optimized
x = y * 0;

// after optimized
x = 0;

// This is not a correct rule.
```

这个优化在大部分场景下对性能的提升都是微不足道的，但最重要的是它是一个 **错误** 的规则。
因为他只对整形变量有效，但对于浮点数，IEEE 浮点标准里规定了 NaN，对于这个规则会破坏该标准，因为 NaN 乘任何数值都是 NaN。

### 第五步：代码生成

代码生成汇编代码，这是最基本的功能，但它也可以将目标语言翻译为别的语言。

## 在 Fortran 之后阶段所占比例的变化

**Fortran**

```
[      Lexical       ][       Parsing        ][Semantic][   Optimization   ][      Co Gen     ]
```

**Latest Compailers**

```
[Lexical][Parsing][         Semantic            ][                      Optimization                      ][ Co Gen ]
```
